<div class="container">

  <div class="modal" ng-controller="UploadController" dropzone> 

    <div class="modal-header">
      <h1>
        Upload Photos to Your Library
        <a class="close" data-dismiss="modal" >&times;</a>
      </h1>
      <p class="lead">
        It should be easy to start. Drag your SD card or USB drive below and wait a few minutes for the files to be scanned, then press Upload and you can soon view your timeline.
      </p>
    </div>
    <div id="dropzone" class="dropzone media modal-body" >
    
      <i class="icon-cloud-upload icon-4x pull-left" ng-show="!files.length"> </i>
      <label ng-show="!files.length"> Drop your photo folder here or select one...
        <input ng-show="!files.length" class="btn-large span3 btn-success" type="file" id="directoryinput" multiple webkitdirectory ng-model="selectedFolder" ng-change="fileChange">
      </label>

      <ul class="media-list">
        <li class="media" ng-repeat="file in files">
          <a class="{{file.state == 'Duplicate' && 'icon-cloud' || file.state == 'Uploading' && 'icon-spinner' || 'icon-cloud-upload' }} pull-left icon-2x"> </a>
          <div class="media-body">
            <h4 class="media-heading">{{file.name}}</h4>
            <div class="progress progress-striped {{file.state == 'Uploading' && 'active' || ''}}">
              <div class="bar {{file.state == 'Error' && 'bar-danger' || file.state == 'Done' && 'bar-success' || ''}}" style="width: {{file.progress || 0}}%;">{{file.state}}</div>
            </div>
          </div>
        </li>
      </ul>

    </div>
    <div class="modal-footer">
      <a href="#" class="btn btn-large btn-success pull-right " ng-click="upload()">Upload {{files.length && files.length + " photos" || ""}}</a>
    </div>
  </div>

</div>

<script>
function UploadController($scope, $http){

  $scope.state = null;
  $scope.files = [];
  /* Drag'n drop stuff */


  //process files
  $scope.fileChange = function (e) {
    var files = e.target.files;
    for(i=0; i<files.length; i++) {
        var file = files[i];
        if(file.type.match(/image.*/)){
            $scope.files.push(file);
        }
    }
  };

  $scope.upload = function(){
    console.log('upload');
    $scope.files.filter(function(file){return !file.state}).slice(0,1).forEach(function(file){
        queue(file, $scope.upload);
    });
  };

  function queue(file) {
    fr   = new FileReader;
    fr.onloadend = function() {
        if ($scope.library && $scope.library.photos){
          var exif = EXIF.readFromBinaryFile(new BinaryFile(this.result));

          if ($scope.library.photos.filter(function(photo){
            var taken = exif.DateTime ? exif.DateTime.slice(0,10).split(':').join('-') + exif.DateTime.slice(10) : null;
            return photo.taken == taken;
          }).length) file.state = "Duplicate";
        }
        
        if (!file.state) {
          upload(file, exif);
        }
    };
    fr.readAsBinaryString(file);
  }

  function upload(file, exif, done){
    var fd = new FormData();
    fd.append(exif.DateTime, file);
    console.log('exif', exif);

    var xhr = new XMLHttpRequest();
    xhr.open("POST", "/api/upload", true);

    xhr.onload = function() {
      if(this.status>200){
        file.state = 'Error';
        file.error = xhr.responseText;
        file.progress = 100;
        return done('error', file);
      } else {
          var response = JSON.parse(xhr.responseText);
          console.log('Done', response);
          file.response = response;
          file.state = 'Done';
          file.progress = 100;
          return done(null, file);
      }
    }

    // Listen to the upload progress.
    xhr.upload.onprogress = function(e) {
      if (e.lengthComputable) {
        file.progress = (e.loaded / e.total) * 100;
        file.state = file.progress >= 100 ? 'Done' : 'Uploading';
      } else {
        file.progress = Math.min(file.progress++, 100);
      }
    };

    file.progress = 1;
    xhr.send(fd);
  }
}
 
</script>

<script src="/js/binaryFile.js"></script>
<script src="/js/exif.js"></script>
